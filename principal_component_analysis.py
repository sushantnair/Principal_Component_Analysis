# -*- coding: utf-8 -*-
"""EXPT6_PCA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C77TmBIGenEx04Fgqu0IZIwfNfz0vXpl
"""

import numpy as np

print(f'Principal Component Analysis (PCA)\nStep 1: Dataset\nFeat Val1 Val2 Val3 Val4')
# features = {'x': [4, 8, 13, 7, 8], 'y': [11, 4, 5, 14, 15], 'z': [1, 2, 3, 5, 6], 'a': [7, 8, 70, 80, 9]}
features = {'x': [4, 8, 13, 7], 'y': [11, 4, 5, 14]}
n = len(features)
N = len(features['x'])
for feature, values in features.items():
    print(feature, *["{:>4}".format(val) for val in values])

print(f'Step 2: Calculate Mean')
mean_dict = {}
for feature, values in features.items():
    sum = 0
    for value in values:
        sum = sum + value
    mean = sum / len(values)
    mean_dict[f'{feature}_bar'] = mean

print(mean_dict)

print(f'Step 3: Covariance Matrix')
print(f'{n} features => {n} by {n} matrix')
# Build the matrix
cov_matrix = np.empty((n,n), dtype=object)
for i, feature_i in enumerate(features):
    for j, feature_j in enumerate(features):
        cov_matrix[i,j] = (feature_i, feature_j)

print(cov_matrix)
cov_mat = np.empty((n,n))
for i in range(cov_matrix.shape[0]):
    for j in range(cov_matrix.shape[1]):
        print(cov_matrix[i,j])
        cov_val = 0
        for k in range(N):
            # Works only for two features
            ''' cov_val = cov_val + ((features[f'{cov_mat[i,j][0]}'][k] - mean_dict[f'{cov_mat[i,j][0]}_bar']) * \
                                    (features[f'{cov_mat[i,j][1]}'][k] - mean_dict[f'{cov_mat[i,j][1]}_bar']))     '''

            # Works for 'n' features in compact fashion
            ''' cov_val = cov_val + ((features[list(features.keys())[i]][k] - mean_dict[f'{list(features.keys())[i]}_bar']) * \
                                    (features[list(features.keys())[j]][k] - mean_dict[f'{list(features.keys())[j]}_bar']))     '''

            prod = 1
            for l in range(len(cov_matrix[i,j])):
                prod = prod * (features[f'{cov_matrix[i,j][l]}'][k] - mean_dict[f'{cov_matrix[i,j][l]}_bar'])
            cov_val = cov_val + prod

        cov_mat[i,j] = cov_val / (N - 1)

print(cov_mat)

# Check for NaN values
if np.isnan(cov_mat).any():
    print("Array contains NaN values")

# Check for inf values
if np.isinf(cov_mat).any():
    print("Array contains inf values")

print(f'Step 4: Eigenvalue; Eigenvector; Normalized Eigenvector')
print(f'Step 4a: Eigen value for v = 1')
print(cov_mat)
eigenvalues, eigenvectors = np.linalg.eig(cov_mat)
print(f'Eigenvalues are: {eigenvalues}')

# Find the index of the maximum eigenvalue
max_egnvalindx = np.argmax(eigenvalues)

# Get the maximum eigenvalue
max_eigenvalue = eigenvalues[max_egnvalindx]

# Get the corresponding Normalized Eigenvector
max_eigenvector = eigenvectors[:, max_egnvalindx]

print(f'Selected Eigenvalue: {max_eigenvalue}')
print(f'Corresponding Normalized Eigenvector: {max_eigenvector}')

print(f'Step 5: Derive n to 1 using First Principal Component')
# Reduced Dimension p
p = dict()

for i in range(N):
    horz_mat = [value[i] - mean_dict[f'{feature}_bar'] for feature, value in features.items()]
    horz_mat = np.array(horz_mat)
    print(horz_mat)
    vert_mat = horz_mat.reshape(-1,1)
    print(vert_mat)
    p_val = np.dot(max_eigenvector, vert_mat)
    print(p_val[0])
    p[f'p1{i+1}'] = round(p_val[0], 4)

print(f'Reduced Dimensions: {p}')

# references
print(features)
for value in features.values():
    print(value)
for feature, value in features.items():
    print(feature, value)